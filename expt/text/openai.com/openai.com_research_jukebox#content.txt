


Jukebox












CloseSearch Submit Skip to main contentSite NavigationResearchOverviewIndexProductOverviewChatGPTGPT-4DALLÂ·E 2Customer storiesSafety standardsAPI data privacyPricingDevelopersOverviewDocumentationAPI referenceExamplesSafetyCompanyAboutBlogCareersCharterSecuritySearch Navigation quick links Log inSign upMenu Mobile Navigation CloseSite NavigationResearchProductDevelopersSafetyCompany Quick Links Log inSign upSearch Submit Illustration: Ben BarryJukeboxWeâre introducing Jukebox, a neural net that generates music, including rudimentary singing, as raw audio in a variety of genres and artist styles. Weâre releasing the model weights and code, along with a tool to explore the generatedÂ samples.April 30, 2020More resourcesRead paperView codeAudio generation,Â Transformers,Â Generative models,Â Open source,Â Jukebox,Â Milestone,Â Publication,Â ReleaseCurated samplesProvided with genre, artist, and lyrics as input, Jukebox outputs a new music sample produced from scratch. Below, we show some of our favorite samples.Unseen lyricsRe-renditionsCompletionsFun songs To hear all uncurated samples, check out our sample explorer. Explore all samplesMotivation and prior workAutomatic music generation dates back to more than half a century.[^reference-1][^reference-2][^reference-3][^reference-4]Â A prominent approach is to generate music symbolically in the form of a piano roll, which specifies the timing, pitch, velocity, and instrument of each note to be played. This has led to impressive results like producing Bach chorals,[^reference-5][^reference-6]Â polyphonic music with multiple instruments,[^reference-7][^reference-8][^reference-9]Â as well as minute long musical pieces.[^reference-10][^reference-11][^reference-12]But symbolic generators have limitationsâthey cannot capture human voices or many of the more subtle timbres, dynamics, and expressivity that are essential to music. A different approach[^footnote-approach] is to model music directly as raw audio.[^reference-13][^reference-14][^reference-15][^reference-16]Â Generating music at the audio level is challenging since the sequences are very long.[^reference-17]Â A typical 4-minute song at CD quality (44 kHz, 16-bit) has over 10 million timesteps. For comparison, GPT-2 had 1,000 timesteps andÂ OpenAI FiveÂ took tens of thousands of timesteps per game. Thus, to learn the high level semantics of music, a model would have to deal with extremely long-rangeÂ dependencies.One way of addressing the long input problem is to use an autoencoder that compresses raw audio to a lower-dimensional space by discarding some of the perceptually irrelevant bits of information. We can then train a model to generate audio in this compressed space, and upsample back to the raw audio space.[^reference-25][^reference-17]We chose to work on music because we want to continue to push the boundaries of generative models. Our previous work onÂ MuseNetÂ explored synthesizing music based on large amounts of MIDI data. Now in raw audio, our models must learn to tackle high diversity as well as very long range structure, and the raw audio domain is particularly unforgiving of errors in short, medium, or long termÂ timing.Raw audioâ44.1k samples per second, where each sample is a float that represents the amplitude of sound at that moment inÂ time Encode using CNNs (convolutional neural networks) Compressed audioâ344 samples per second, where each sample is 1 of 2048 possible vocabÂ tokens Generate novel patterns from trained transformer conditioned on lyrics Novel compressed audioâ344 samples per second Upsample using transformers and decode using CNNs Novel raw audioâ44.1k samples per secondApproachCompressing music to discrete codesJukeboxâs autoencoder model compresses audio to a discrete space, using a quantization-based approach called VQ-VAE.[^reference-25]Â Hierarchical VQ-VAEs[^reference-17]Â can generate short instrumental pieces from a few sets of instruments, however they suffer from hierarchy collapse due to use of successive encoders coupled with autoregressive decoders. A simplified variant called VQ-VAE-2[^reference-26]Â avoids these issues by using feedforward encoders and decoders only, and they show impressive results at generating high-fidelityÂ images.We draw inspiration from VQ-VAE-2 and apply their approach to music. We modify their architecture asÂ follows:To alleviate codebook collapse common to VQ-VAE models, we use random restarts where we randomly reset a codebook vector to one of the encoded hidden states whenever its usage falls below aÂ threshold.To maximize the use of the upper levels, we use separate decoders and independently reconstruct the input from the codes of eachÂ level.To allow the model to reconstruct higher frequencies easily, we add a spectral loss[^reference-27][^reference-28]Â that penalizes the norm of the difference of input and reconstructedÂ spectrograms.We use three levels in our VQ-VAE, shown below, which compress the 44kHz raw audio by 8x, 32x, and 128x, respectively, with a codebook size of 2048 for each level. This downsampling loses much of the audio detail, and sounds noticeably noisy as we go further down the levels. However, it retains essential information about the pitch, timbre, and volume of theÂ audio.CompressGenerate Each VQ-VAE level independently encodes the input. The bottom level encoding produces the highest quality reconstruction, while the top level encoding retains only the essential musical information. Generating codes using transformersNext, we train the prior models whose goal is to learn the distribution of music codes encoded by VQ-VAE and to generate music in this compressed discrete space. Like the VQ-VAE, we have three levels of priors: a top-level prior that generates the most compressed codes, and two upsampling priors that generate less compressed codes conditioned onÂ above.The top-level prior models the long-range structure of music, and samples decoded from this level have lower audio quality but capture high-level semantics like singing and melodies. The middle and bottom upsampling priors add local musical structures like timbre, significantly improving the audioÂ quality.We train these as autoregressive models using a simplified variant of Sparse Transformers.[^reference-29][^reference-30]Â Each of these models has 72 layers of factorized self-attention on a context of 8192 codes, which corresponds to approximately 24 seconds, 6 seconds, and 1.5 seconds of raw audio at the top, middle and bottom levels,Â respectively.Once all of the priors are trained, we can generate codes from the top level, upsample them using the upsamplers, and decode them back to the raw audio space using the VQ-VAE decoder to sample novelÂ songs.DatasetTo train this model, we crawled the web to curate a new dataset of 1.2 million songs (600,000 of which are in English), paired with the corresponding lyrics and metadata fromÂ LyricWiki. The metadata includes artist, album genre, and year of the songs, along with common moods or playlist keywords associated with each song. We train on 32-bit, 44.1 kHz raw audio, and perform data augmentation by randomly downmixing the right and left channels to produce monoÂ audio.Artist and genre conditioningThe top-level transformer is trained on the task of predicting compressed audio tokens. We can provide additional information, such as the artist and genre for each song. This has two advantages: first, it reduces the entropy of the audio prediction, so the model is able to achieve better quality in any particular style; second, at generation time, we are able to steer the model to generate in a style of ourÂ choosing.This t-SNE[^reference-31]Â below shows how the model learns, in an unsupervised way, to cluster similar artists and genres close together, and also makes some surprising associations like Jennifer Lopez being so close to DollyÂ Parton!Lyrics conditioningIn addition to conditioning on artist and genre, we can provide more context at training time by conditioning the model on the lyrics for a song. A significant challenge is the lack of a well-aligned dataset: we only have lyrics at a song level without alignment to the music, and thus for a given chunk of audio we donât know precisely which portion of the lyrics (if any) appear. We also may have song versions that donât match the lyric versions, as might occur if a given song is performed by several different artists in slightly different ways. Additionally, singers frequently repeat phrases, or otherwise vary the lyrics, in ways that are not always captured in the writtenÂ lyrics.To match audio portions to their corresponding lyrics, we begin with a simple heuristic that aligns the characters of the lyrics to linearly span the duration of each song, and pass a fixed-size window of characters centered around the current segment during training. While this simple strategy of linear alignment worked surprisingly well, we found that it fails for certain genres with fast lyrics, such as hip hop. To address this, we use Spleeter[^reference-32]Â to extract vocals from each song and run NUS AutoLyricsAlign[^reference-33]Â on the extracted vocals to obtain precise word-level alignments of the lyrics. We chose a large enough window so that the actual lyrics have a high probability of being inside theÂ window.To attend to the lyrics, we add an encoder to produce a representation for the lyrics, and add attention layers that use queries from the music decoder to attend to keys and values from the lyrics encoder. After training, the model learns a more preciseÂ alignment.Lyricâmusic alignment learned by encoderâdecoder attention layerAttention progresses from one lyric token to the next as the music progresses, with a few moments of uncertainty.LimitationsWhile Jukebox represents a step forward in musical quality, coherence, length of audio sample, and ability to condition on artist, genre, and lyrics, there is a significant gap between these generations and human-createdÂ music.For example, while the generated songs show local musical coherence, follow traditional chord patterns, and can even feature impressive solos, we do not hear familiar larger musical structures such as choruses that repeat. Our downsampling and upsampling process introduces discernable noise. Improving the VQ-VAE so its codes capture more musical information would help reduce this. Our models are also slow to sample from, because of the autoregressive nature of sampling. It takes approximately 9 hours to fully render one minute of audio through our models, and thus they cannot yet be used in interactive applications. Using techniques[^reference-27][^reference-34]Â that distill the model into a parallel sampler can significantly speed up the sampling speed. Finally, we currently train on English lyrics and mostly Western music, but in the future we hope to include songs from other languages and parts of theÂ world.Future directionsOur audio team is continuing to work on generating audio samples conditioned on different kinds of priming information. In particular, weâve seen early success conditioning on MIDI files and stem files. Hereâs an example of aÂ raw audio sampleÂ conditioned onÂ MIDI tokens. We hope this will improve the musicality of samples (in the way conditioning on lyrics improved the singing), and this would also be a way of giving musicians more control over the generations. We expect human and model collaborations to be an increasingly exciting creative space. If youâre excited to work on these problems with us,Â weâreÂ hiring.As generative modeling across various domains continues to advance, we are also conducting research into issues likeÂ biasÂ andÂ intellectual property rights, and are engaging with people who work in the domains where we develop tools. To better understand future implications for the music community, we shared Jukebox with an initial set of 10 musicians from various genres to discuss their feedback on this work. While Jukebox is an interesting research result, these musicians did not find it immediately applicable to their creative process given some of its currentÂ limitations. We are connecting with the wider creative community as we think generative work across text, images, and audio will continue to improve. If youâre interested in being a creative collaborator to help us buildÂ useful toolsÂ or new works of art in these domains, pleaseÂ let usÂ know!To connect with the corresponding authors, please emailÂ jukebox@openai.com.Creative collaborator sign-upTimeline2019AugustOur first raw audio model, which learns to recreate instruments like Piano and Violin. We try a dataset of rock and pop songs, and surprisingly it works.2019OctoberWe collect a larger and more diverse dataset of songs, with labels for genres and artists. Model picks up artist and genre styles more consistently with diversity, and at convergence can also produce full-length songs with long-range coherence.2020JanuaryWe scale our VQ-VAE from 22 to 44kHz to achieve higher quality audio. We also scale top-level prior from 1B to 5B to capture the increased information. We see better musical quality, clear singing, and long-range coherence. We also make novel completions of real songs.2020FebruaryWe start training models conditioned on lyrics to incorporate further conditioning information. We only have unaligned lyrics, so model has to learn alignment and pronunciation, as well as singing.AuthorsEqual contributosPrafulla DhariwalHeewoo JunChristine McLeavey PayneContributosJong Wook KimAlec RadfordIlya SutskeverAcknowledgmentsThank you to the following for their feedback on this work and contributions to this release: Jack Clark, Gretchen Krueger, Miles Brundage, Jeff Clune, Jakub Pachocki, Ryan Lowe, Shan Carter, David Luan, Vedant Misra, Daniela Amodei, Greg Brockman, Kelly Sims, Karson Elmgren, Bianca Martin, Rewon Child, Will Guss, Rob Laidlow, Rachel White, Delwin Campbell, Tasso Smith, Matthew Suttor, Konrad Kaczmarek, Scott Petersen, Dakota Stipp, Jena EzzeddineEditor: Ashley PilipiszynDesign & Development: Justin Jay Wang & Brooke ChanResearchOverviewIndexProductOverviewChatGPTGPT-4DALLÂ·E 2Customer storiesSafety standardsAPI data privacyPricingSafetyOverviewCompanyAboutBlogCareersCharterSecurityOpenAI Â© 2015âââ2023Terms & policiesPrivacy policyBrand guidelinesSocialTwitterYouTubeGitHubSoundCloudLinkedInBack to top
