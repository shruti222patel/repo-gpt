


Solving Rubik’s Cube with a robot hand












CloseSearch Submit Skip to main contentSite NavigationResearchOverviewIndexProductOverviewChatGPTGPT-4DALLÂ·E 2Customer storiesSafety standardsAPI data privacyPricingDevelopersOverviewDocumentationAPI referenceExamplesSafetyCompanyAboutBlogCareersCharterSecuritySearch Navigation quick links Log inSign upMenu Mobile Navigation CloseSite NavigationResearchProductDevelopersSafetyCompany Quick Links Log inSign upSearch Submit Photo: Eric HainesSolving Rubikâs Cube with a robot handWeâve trained a pair of neural networks to solve the Rubikâs Cube with a human-like robot hand. The neural networks are trained entirely in simulation, using the same reinforcement learning code asÂ OpenAI FiveÂ paired with a new technique called Automatic Domain Randomization (ADR). The system can handle situations it never saw during training, such as being prodded by aÂ stuffed giraffe. This shows that reinforcement learning isnât just a tool for virtual tasks, but can solve physical-world problems requiring unprecedented dexterity.October 15, 2019More resourcesRead paperWatch all videosRobotics,Â Domain randomization,Â Meta-learning,Â Sim-to-real,Â Transfer learning,Â Dactyl,Â Milestone,Â PublicationPlay videoHuman hands let us solve a wide variety of tasks. For the past 60 years of robotics, hard tasks which humans accomplish with their fixed pair of hands have required designing a custom robot forÂ each task. As an alternative, people have spentÂ many decades trying to use general-purpose robotic hardware, but with limited success due to their high degrees of freedom. In particular, the hardware we use here is not newâthe robot hand we use has been around for the last 15 yearsâbut the software approachÂ is.Since May 2017, weâve been trying to train a human-like robotic hand to solve theÂ Rubikâs Cube. We set this goal because we believe that successfully training such a robotic hand to do complex manipulation tasks lays the foundation for general-purpose robots. We solved the Rubikâs Cube in simulation in July 2017. But as of July 2018, we could onlyÂ manipulate a blockÂ on the robot. Now, weâve reached our initialÂ goal.Solving Rubikâs Cube with a Robot Hand:  Uncut04:08A full solve of the Rubikâs Cube. This video plays at real-time and was not edited in any way.Solving a Rubikâs Cube one-handed is a challenging task even for humans, and it takes children several years to gain the dexterity required to master it. Our robotÂ still hasnât perfected its techniqueÂ though, as it solves the Rubikâs Cube 60% of the time (and only 20% of the time for aÂ maximally difficultÂ scramble).Our approachWe train neural networks to solve the Rubikâs Cube inÂ simulationÂ usingÂ reinforcement learningÂ andÂ Kociembaâs algorithmÂ for picking the solution steps.[^footnote-steps] DomainÂ randomizationÂ enables networks trained solely in simulation to transfer to a realÂ robot.The biggest challenge we faced was to create environments in simulation diverse enough to capture the physics of the real world. Factors like friction, elasticity and dynamics are incredibly difficult to measure and model for objects as complex as Rubikâs Cubes or robotic hands and we found that domain randomization alone is notÂ enough.To overcome this, we developed a new method calledÂ Automatic Domain RandomizationÂ (ADR), which endlessly generates progressively more difficult environments in simulation.[^footenote-adr] This frees us from having an accurate model of the real world, and enables the transfer of neural networks learned in simulation to be applied to the realÂ world.ADR starts with a single, nonrandomized environment, wherein a neural network learns to solve Rubikâs Cube. As the neural network gets better at the task and reaches a performance threshold, the amount of domain randomization is increased automatically. This makes the task harder, since the neural network must now learn to generalize to more randomized environments. The network keeps learning until it again exceeds the performance threshold, when more randomization kicks in, and the process isÂ repeated.ADR applied to the size of the Rubikâs CubeOne of the parameters we randomize is the size of the Rubikâs Cube (above). ADR begins with a fixed size of the Rubikâs Cube and gradually increases the randomization range as training progresses. We apply the same technique to all other parameters, such as the mass of the cube, the friction of the robot fingers, and the visual surface materials of the hand. The neural network thus has to learn to solve the Rubikâs Cube under all of those increasingly more difficultÂ conditions.Automatic vs. manual domain randomizationDomain randomization required us to manually specify randomization ranges, which is difficult since too much randomization makes learning difficult but too little randomization hinders transfer to the real robot. ADR solves this by automatically expanding randomization ranges over time with no human intervention. ADR removes the need for domain knowledge and makes it simpler to apply our methods to new tasks. In contrast to manual domain randomization, ADR also keeps the task always challenging with training neverÂ converging.We compared ADR to manual domain randomization on the block flipping task, where we already had aÂ strong baseline. In the beginning ADR performs worse in terms of number of successes on the real robot. But as ADR increases the entropy, which is a measure of the complexity of the environment, the transfer performance eventually doubles over the baselineâwithout humanÂ tuning.AnalysisTesting for robustnessUsing ADR, we are able to train neural networks in simulation that can solve the Rubikâs Cube on the real robot hand. This is because ADR exposes the network to an endless variety of randomized simulations. It is this exposure to complexity during training that prepares the network to transfer from simulation to the real world since it has to learn to quickly identify and adjust to whatever physical world it is confrontedÂ with.Unperturbed (for reference)Rubber gloveTied fingersBlanket occlusion and perturbationPlush giraffe perturbationPen perturbation Perturbations that we apply to the real robot hand while it solves the Rubikâs Cube. All videos play at real-time. To test the limits of our method, we experiment with a variety of perturbations while the hand is solving the Rubikâs Cube. Not only does this test for the robustness of our control network but also tests our vision network, which we here use to estimate the cubeâs position andÂ orientation.We find that our system trained with ADR is surprisingly robust to perturbations even though we never trained with them: The robot can successfully perform most flips and face rotations under all tested perturbations, though not at peakÂ performance.Emergent meta-learningWe believe thatÂ meta-learning, or learning to learn, is an important prerequisite for building general-purpose systems, since it enables them to quickly adapt to changing conditions in their environments. The hypothesis behind ADR is that a memory-augmented networks combined with a sufficiently randomized environment leads toÂ emergent meta-learning, where the network implements a learning algorithm that allows itself to rapidly adapt its behavior to the environment it is deployed in.[^footnote-deployed]To test this systematically, we measure the time to success per cube flip (rotating the cube such that a different color faces up) for our neural network under different perturbations, such as resetting the networkâs memory, resetting the dynamics, or breaking a joint. We perform these experiments in simulation, which allows us to average performance over 10,000 trials in a controlledÂ setting.Reset memoryReset dynamicsBroken jointTime to success when the robot is impaired by breaking a random jointTime to success when friction, mass, or gravity changeTime to success when the robot is impaired by breaking a random jointIn the beginning, as the neural network successfully achieves more flips, each successive time to success decreases because the network learns to adapt. When perturbations are applied (vertical gray lines in the above chart), we see a spike in time to success. This is because the strategy the network is employing doesnât work in the changed environment. The network then relearns about the new environment and we again see time to success decrease to the previousÂ baseline.We also measure failure probability and performed the same experiments for face rotations (rotating the top face 90 degrees clockwise or counterclockwise) and find the same pattern of adaptation.[^footnote-results]Understanding our neural networksVisualizing our networks enables us to understand what they are storing in memory. This becomes increasingly important as the networks grow inÂ complexity.0:00The memory of our neural network is visualized above. We use aÂ building block from the interpretability toolbox, namely non-negative matrix factorization, to condense this high-dimensional vector into 6 groups and assign each a unique color. We then display the color of the currently dominant group for everyÂ timestep.We find that each memory group has a semantically meaningful behavior associated with it. For example, we can tell by looking at only the dominant group of the networkâs memory if it is about to spin the cube or rotate the top clockwiseÂ before itÂ happens.ChallengesSolving the Rubikâs Cube with a robot hand is still not easy. Our method currently solves the Rubikâs Cube 20% of the time when applying aÂ maximally difficult scrambleÂ that requires 26 face rotations. For simpler scrambles that require 15 rotations to undo, the success rate is 60%. When the Rubikâs Cube is dropped or a timeout is reached, we consider the attempt failed. However, our network is capable of solving the Rubikâs Cube from any initial condition. So if the cube is dropped, it is possible to put it back into the hand and continueÂ solving.We generally find that our neural network is much more likely to fail during the first few face rotations and flips. This is the case because the neural network needs to balance solving the Rubikâs Cube with adapting to the physical world during those early rotations andÂ flips.Behind the scenes: Rubikâs Cube prototypesIn order to benchmark our progress and make the problem tractable, we built and designed custom versions of cubes as stepping stones towards ultimately solving a regular Rubikâs Cube.[^footnote-modifications]Rubikâs Cube prototypes, from left to right: Locked cube, Face cube, Full cube, Giiker cube, regular Rubikâs Cube.PrototypePosition + orientationInternal degrees of freedom (sensor)Locked cubVision0 (No sensor)Face cubPhaseSpace2â(PhaseSpace)Full cubePhaseSpace6â(PhaseSpace)Giiker cubeVision6â(Built-in sensors)Regular Rubikâs CubeVision6â(Vision)Next stepsWe believe that human-level dexterity is on the path towards building general-purpose robots and we are excited to push forward in thisÂ direction.If you want to help make increasingly general AI systems, whether robotic or virtual,Â weâreÂ hiring!AuthorsOpenAI Ilge AkkayaMarcin AndrychowiczMaciek ChociejMateusz LitwinBob McGrewArthur PetronAlex PainoMatthias PlappertGlenn PowellRaphael RibasJonas SchneiderNikolas TezakJerry TworekPeter WelinderLilian WengQiming YuanWojciech ZarembaLei ZhangAcknowledgmentsThanks to the following for feedback on drafts of this post and paper: Josh Achiam, Greg Brockman, Nick Cammarata, Jack Clark, Jeff Clune, Ruben DâSa, Harri Edwards, David Farhi, Ken Goldberg, Leslie P. Kaelbling, Hyeonwoo Noh, Lerrel Pinto, John Schulman, Ilya Sutskever & Tao Xu.Video: Peter Jordan (Director), Yvette Solis (Producer), Brooke Chan (Producer)Editor: Ashley PilipiszynDesign: Justin Jay Wang & Ben BarryPhotography: Eric HainesResearchOverviewIndexProductOverviewChatGPTGPT-4DALLÂ·E 2Customer storiesSafety standardsAPI data privacyPricingSafetyOverviewCompanyAboutBlogCareersCharterSecurityOpenAI Â© 2015âââ2023Terms & policiesPrivacy policyBrand guidelinesSocialTwitterYouTubeGitHubSoundCloudLinkedInBack to top
